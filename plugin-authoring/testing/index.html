<!DOCTYPE html>
<html>
  <head>
    <meta content='IE=edge,chrome=1' http-equiv='X-UA-Compatible'>
    <meta content='width=device-width, initial-scale=1.0' name='viewport'>
    <link href="/images/favicon.ico" rel="icon" type="image/ico" />
    <title>Plugin Authoring: Testing - Lita.io</title>
    <meta content='Documentation for Lita, a chat bot written in Ruby.' name='description'>
    <link href="/stylesheets/application-24781433.css" rel="stylesheet" />
    <script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create', 'UA-5500916-13', 'lita.io');ga('send', 'pageview');</script>
  </head>
  <body>
    <nav class='navbar navbar-default navbar-static-top navbar-inverse' role='navigation'>
      <div class='container'>
        <a class="navbar-brand hidden-xs" href="/">Lita Documentation</a>
        <ul class='nav navbar-nav navbar-right'>
          <li class='dropdown'>
            <a href='/getting-started/'>
              Getting Started
              <b class='caret'></b>
            </a>
            <ul class='dropdown-menu'>
              <li><a href="/getting-started/">Overview</a></li>
              <li><a href="/getting-started/installation/">Installation</a></li>
              <li><a href="/getting-started/plugins/">Plugins</a></li>
              <li><a href="/getting-started/configuration/">Configuration</a></li>
              <li><a href="/getting-started/usage/">Usage</a></li>
              <li><a href="/getting-started/deployment/">Deployment</a></li>
              <li><a href="/getting-started/versioning-policy/">Versioning Policy</a></li>
            </ul>
          </li>
          <li class='dropdown'>
            <a href='/plugin-authoring/'>
              Plugin Authoring
              <b class='caret'></b>
            </a>
            <ul class='dropdown-menu'>
              <li><a href="/plugin-authoring/">Overview</a></li>
              <li><a href="/plugin-authoring/adapters/">Adapters</a></li>
              <li><a href="/plugin-authoring/handlers/">Handlers</a></li>
              <li><a href="/plugin-authoring/events/">Events</a></li>
              <li><a href="/plugin-authoring/localization/">Localization</a></li>
              <li><a href="/plugin-authoring/extensions/">Extensions</a></li>
              <li><a href="/plugin-authoring/testing/">Testing</a></li>
              <li><a href="/plugin-authoring/publishing/">Publishing</a></li>
            </ul>
          </li>
          <li class='dropdown'>
            <a href='/releases/'>
              Releases
              <b class='caret'></b>
            </a>
            <ul class='dropdown-menu'>
              <li><a href="/releases/4/">Lita 4</a></li>
              <li><a href="/releases/3/">Lita 3</a></li>
            </ul>
          </li>
          <li class='navbar-link'><a href="https://www.lita.io/">Lita.io <span class="glyphicon glyphicon-arrow-right"></span></a></li>
        </ul>
      </div>
    </nav>
    <div class='content'>
      <div class='container'>
        <div class='page-header'>
          <h1>Plugin Authoring</h1>
        </div>
        <div class='row'>
          <div class='col-md-3'>
            <nav>
              <ul class='nav nav-stacked'>
                <li>
                  <a href="/plugin-authoring/">Overview</a>
                  <ul>
                    <li><a href="/plugin-authoring/#plugin-types">Plugin types</a></li>
                    <li><a href="/plugin-authoring/#plugin-loading">Plugin loading</a></li>
                  </ul>
                </li>
                <li>
                  <a href="/plugin-authoring/adapters/">Adapters</a>
                  <ul>
                    <li><a href="/plugin-authoring/adapters/#generating">Generating an adapter</a></li>
                    <li><a href="/plugin-authoring/adapters/#configuration">Configuration</a></li>
                    <li><a href="/plugin-authoring/adapters/#required-methods">Required methods</a></li>
                    <li><a href="/plugin-authoring/adapters/#helper-methods">Helper methods</a></li>
                    <li><a href="/plugin-authoring/adapters/#chat-service">Chat-service-specific methods</a></li>
                    <li><a href="/plugin-authoring/adapters/#block-syntax">Block syntax</a></li>
                  </ul>
                </li>
                <li>
                  <a href="/plugin-authoring/handlers/">Handlers</a>
                  <ul>
                    <li><a href="/plugin-authoring/handlers/#chat-routes">Chat routes</a></li>
                    <li><a href="/plugin-authoring/handlers/#http-routes">HTTP routes</a></li>
                    <li><a href="/plugin-authoring/handlers/#event-routes">Event routes</a></li>
                    <li><a href="/plugin-authoring/handlers/#mixins">Mixins</a></li>
                    <li><a href="/plugin-authoring/handlers/#helper-methods">Helper methods</a></li>
                    <li><a href="/plugin-authoring/handlers/#timers">Timers</a></li>
                    <li><a href="/plugin-authoring/handlers/#configuration">Configuration</a></li>
                    <li><a href="/plugin-authoring/handlers/#chat-service">Chat-service-specific methods</a></li>
                    <li><a href="/plugin-authoring/handlers/#examples">Examples</a></li>
                  </ul>
                </li>
                <li>
                  <a href="/plugin-authoring/configuration/">Configuration</a>
                </li>
                <li>
                  <a href="/plugin-authoring/events/">Events</a>
                  <ul>
                    <li><a href="/plugin-authoring/events/#built-in-events">Built-in events</a></li>
                  </ul>
                </li>
                <li><a href="/plugin-authoring/localization/">Localization</a></li>
                <li>
                  <a href="/plugin-authoring/extensions/">Extensions</a>
                  <ul>
                    <li><a href="/plugin-authoring/extensions/#hooks">Hooks</a></li>
                    <li><a href="/plugin-authoring/extensions/#examples">Examples</a></li>
                    <li><a href="/plugin-authoring/extensions/#using-extensions">Using Extensions</a></li>
                  </ul>
                </li>
                <li>
                  <a href="/plugin-authoring/testing/">Testing</a>
                  <ul>
                    <li><a href="/plugin-authoring/testing/#setup">Setup</a></li>
                    <li><a href="/plugin-authoring/testing/#testing-adapters">Testing adapters</a></li>
                    <li><a href="/plugin-authoring/testing/#testing-handlers">Testing handlers</a></li>
                    <li><a href="/plugin-authoring/testing/#testing-routes">Testing routes</a></li>
                    <li><a href="/plugin-authoring/testing/#testing-behavior">Testing behavior</a></li>
                  </ul>
                </li>
                <li><a href="/plugin-authoring/publishing/">Publishing</a></li>
              </ul>
            </nav>
          </div>
          <div class='col-md-9'>
            <div class='page-header first-heading'>
              <h2>Testing</h2>
            </div>
            <p>It's a core philosophy of Lita that any plugins you write for your robot should be as thoroughly tested as any other program you would write. To make this easier, Lita ships with some handy extras for <a href="https://github.com/rspec/rspec">RSpec</a> that make testing a plugin dead simple. Since Lita plugins are just Ruby code, they can be tested with any framework you like, but RSpec is recommended for its expressiveness and powerful features.</p>
            
            <h3 id="setup">Setup</h3>
            
            <p>If you created your plugin with the built-in generator, the files necessary for your RSpec test suite will already be in place in the <code>spec</code> directory. If you're building your plugin manually, you only need to require your plugin and Lita's RSpec extras before writing your tests. It's recommended that you put this in <code>spec/spec_helper.rb</code> and then simply require "spec_helper" in each spec file.</p>
            
            <pre><code class="language-ruby">require "lita-your-plugin"&#x000A;require "lita/rspec"&#x000A;</code></pre>
            
            <h3 id="testing-adapters">Testing adapters and extensions</h3>
            
            <p>To include some helpful setup for testing Lita code, require "lita/rspec", then add <code>lita: true</code> to the metadata for an example group.
            Adapters and extensions should be unit tested as you would any other Ruby code. For a few workflow improvements, activate <code>Lita::RSpec</code> by passing <code>:lita</code> as RSpec metadata on your plugin's example group:</p>
            
            <pre><code class="language-ruby">describe Lita::Adapters::MyAdapter, lita: true do&#x000A;  describe "#run" do&#x000A;    # ...&#x000A;  end&#x000A;&#x000A;  # ...&#x000A;end&#x000A;</code></pre>
            
            <p>Turning on <code>Lita::RSpec</code> will have the following effects:</p>
            
            <ul>
              <li>All Redis interaction will be namespaced to a test environment and automatically cleared out before each example.</li>
              <li>Lita's logger is stubbed to prevent log messages from cluttering up your test output.</li>
              <li>A brand new <code>Lita::Registry</code> is created for each test and made accessible via the <code>registry</code> method. The registry is used to hold global state such as all the plugins Lita knows about and the user configuration.</li>
            </ul>
            
            <p>The first two points you don't really have to think about. The third one you will likely interact with directly. To create an instance of an adapter, you must pass a <code>Lita::Robot</code> as an argument. The robot, in turn, takes a registry as an argument. Your set up code will end looking something like this:</p>
            
            <pre><code class="language-ruby">describe Lita::Adapters::MyAdapter, lita: true do&#x000A;  let(:robot) { Lita::Robot.new(registry) }&#x000A;  subject { described_class.new(robot) }&#x000A;end&#x000A;</code></pre>
            
            <p>At this point you'll have a functioning instance of your adapter as the test subject and can proceed normally.</p>
            
            <h3 id="testing-handlers">Testing handlers</h3>
            
            <p>The setup for testing a handler is similar, but use <code>:lita_handler</code> as metadata instead.</p>
            
            <pre><code class="language-ruby">describe Lita::Handlers::MyHandler, lita_handler: true do&#x000A;  # ...&#x000A;end&#x000A;</code></pre>
            
            <p>This will have the following effects, in addition to the effects of the <code>lita: true</code> metadata hook:</p>
            
            <ul>
              <li>Your handler will automatically be added to the registry before each example.</li>
              <li>Strings sent with <code>Lita::Robot#send_messages</code> will be pushed to an array accessible as <code>replies</code> so you can make expectations about output from the robot.</li>
              <li>You have access to the following cached objects set with <code>let</code>:
                <ul>
                  <li><code>robot</code> – a <code>Lita::Robot</code></li>
                  <li><code>source</code> – a <code>Lita::Source</code>, the source of the incoming message</li>
                  <li><code>user</code> – a <code>Lita::User</code>, the user who sent the message, attached to the source</li>
                </ul>
            
                <p>Note that these objects are instances of the real classes and not test doubles.</p>
              </li>
            </ul>
            
            <p>If you need to register additional handlers, for cases when functionality is divided or shared across multiple classes, you can use the <code>:additional_lita_handlers</code> metadata hook:</p>
            
            <pre><code class="language-ruby">describe Lita::Handlers::MyHandler, lita_handler: true, additional_lita_handlers: SharedConfig do&#x000A;  # ...&#x000A;end&#x000A;</code></pre>
            
            <p>This will register both <code>MyHandler</code> and <code>SharedConfig</code> for each example. The value of <code>:additional_lita_handlers</code> can be a single object or an array of objects.</p>
            
            <h4 id="testing-routes">Testing routes</h4>
            
            <p>You can test routes of all types very easily using these RSpec matchers:</p>
            
            <pre><code class="language-ruby"># Chat routes&#x000A;it { is_expected.to route("some message") }&#x000A;it { is_expected.to route("some message").to(:some_callback) }&#x000A;it { is_expected.to route_command("some command") }&#x000A;it { is_expected.to route_command("some command").to(:some_other_callback) }&#x000A;it { is_expected.to route("secret").with_authorization_for(:secret_admins).to(:secret_callback) }&#x000A;&#x000A;# HTTP routes&#x000A;it { is_expected.to route_http(:get, "/foo") }&#x000A;it { is_expected.to route_http(:get, "/foo").to(:some_http_callback) }&#x000A;&#x000A;# Event routes&#x000A;it { is_expected.to route_event(:some_event) }&#x000A;it { is_expected.to route_event(:some_event).to(:some_event_callback) }&#x000A;</code></pre>
            
            <p>Matchers with a fluent (chained) interface make the expectation more specific. If the name of a route is not specified, RSpec will only verify that the message, HTTP request, or event routes to <em>any</em> callback. The <code>with_authorization_for</code> method is necessary to verify routes that are restricted to certain authorization groups.</p>
            
            <p>Each of these matchers can be turned into a negative expectation by writing <code>is_expected.not_to</code> instead of <code>is_expected.to</code>. The matchers themselves are the same in both positive and negative forms.</p>
            
            <div class="alert alert-info">
              <strong>Note:</strong>
              As always, be careful when making negative message expectations, as a route might fail to match for a reason other than why you think. Positive message expectations are always preferred when possible.
            </div>
            
            <h4 id="testing-behavior">Testing behavior</h4>
            
            <p>Since the behavioral logic in handlers are just regular instance methods (unless you use the defined callbacks with a block), you can unit test them just as you would any other methods in a Ruby class. However, if you prefer more of an integration testing approach, there are some helper methods available to assist with this.</p>
            
            <p>To send a message to the robot, use <code>send_message</code> and <code>send_command</code>. Then set expectations about the contents of the <code>replies</code> array.</p>
            
            <pre><code class="language-ruby">it "lets everyone know when someone is happy" do&#x000A;  send_message("I'm happy!")&#x000A;  expect(replies.last).to eq("Hey, everyone! #{user.name} is happy! Isn't that nice?")&#x000A;end&#x000A;&#x000A;it "greets anyone that says hi to it" do&#x000A;  send_command("hi")&#x000A;  expect(replies.last).to eq("Hello, #{user.name}!")&#x000A;end&#x000A;</code></pre>
            
            <p>If you want to send a message or command from a user other than the default test user (which is set up for you with <code>let(:user)</code> automatically by <code>Lita::RSpec</code>), you can invoke either method with the <code>:as</code> option, supplying a <code>Lita::User</code> object.</p>
            
            <pre><code class="language-ruby">it "lets everyone know that Carl is happy" do&#x000A;  carl = Lita::User.create(123, name: "Carl")&#x000A;  send_message("I'm happy!", as: carl)&#x000A;  expect(replies.last).to eq("Hey, everyone! Carl is happy! Isn't that nice?")&#x000A;end&#x000A;</code></pre>
            
            <p>You can also specify that a message came from a certain chat room with the <code>:from</code> option and a <code>Lita::Room</code> object.</p>
            
            <pre><code class="language-ruby">it "replies with the room the message came from" do&#x000A;  send_message("Where am I?", from: Lita::Room.create("#lita.io"))&#x000A;  expect(replies.last).to eq("You are chatting in #lita.io!")&#x000A;end&#x000A;</code></pre>
            
            <p>To test the behavior of an HTTP route callback, use the <code>http</code> method. This method returns a <code>Faraday::Connection</code> object. Call one of the standard HTTP verb methods on this object to make an HTTP request and return a response. Then you can set expectations about the response.</p>
            
            <pre><code class="language-ruby">describe "#foo" do&#x000A;  it "writes 'bar' to the page" do&#x000A;    response = http.get("/foo")&#x000A;    expect(response.body).to eq("bar")&#x000A;  end&#x000A;end&#x000A;</code></pre>
            
            <div class="alert alert-info">
              <strong>Note:</strong>
              The <code>http</code> method requires that the <code>rack-test</code> gem be part of your bundle, either in the Gemfile or set as a development dependency in your plugin's gemspec.
            </div>
          </div>
        </div>
      </div>
    </div>
    <footer>
      <div class='container'>
        <ul class='nav navbar-nav'>
          <li><a href="https://github.com/litaio/lita">GitHub</a></li>
          <li><a href="https://twitter.com/litachatbot">Twitter</a></li>
          <li><a href="https://groups.google.com/group/litaio">Mailing List</a></li>
          <li><a href="http://webchat.freenode.net/?channels=lita.io">IRC</a></li>
          <li><a href="http://www.stickermule.com/marketplace/2466-lita">Stickers</a></li>
        </ul>
        <ul class='nav navbar nav navbar-right'>
          <li>
            <div class='navbar-text'>© 2015 Lita.io</div>
          </li>
        </ul>
      </div>
    </footer>
    <script src="/javascripts/application-7a3c79c9.js"></script>
  </body>
</html>
