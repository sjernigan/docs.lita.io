<!DOCTYPE html>
<html>
  <head>
    <meta content='IE=edge,chrome=1' http-equiv='X-UA-Compatible'>
    <meta content='width=device-width, initial-scale=1.0' name='viewport'>
    <link href="/images/favicon.ico" rel="icon" type="image/ico" />
    <title>Plugin Authoring: Extensions - Lita.io</title>
    <meta content='Documentation for Lita, a chat bot written in Ruby.' name='description'>
    <link href="/stylesheets/application-24781433.css" rel="stylesheet" />
    <script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create', 'UA-5500916-13', 'lita.io');ga('send', 'pageview');</script>
  </head>
  <body>
    <nav class='navbar navbar-default navbar-static-top navbar-inverse' role='navigation'>
      <div class='container'>
        <a class="navbar-brand hidden-xs" href="/">Lita Documentation</a>
        <ul class='nav navbar-nav navbar-right'>
          <li class='dropdown'>
            <a href='/getting-started/'>
              Getting Started
              <b class='caret'></b>
            </a>
            <ul class='dropdown-menu'>
              <li><a href="/getting-started/">Overview</a></li>
              <li><a href="/getting-started/installation/">Installation</a></li>
              <li><a href="/getting-started/plugins/">Plugins</a></li>
              <li><a href="/getting-started/configuration/">Configuration</a></li>
              <li><a href="/getting-started/usage/">Usage</a></li>
              <li><a href="/getting-started/deployment/">Deployment</a></li>
              <li><a href="/getting-started/versioning-policy/">Versioning Policy</a></li>
            </ul>
          </li>
          <li class='dropdown'>
            <a href='/plugin-authoring/'>
              Plugin Authoring
              <b class='caret'></b>
            </a>
            <ul class='dropdown-menu'>
              <li><a href="/plugin-authoring/">Overview</a></li>
              <li><a href="/plugin-authoring/adapters/">Adapters</a></li>
              <li><a href="/plugin-authoring/handlers/">Handlers</a></li>
              <li><a href="/plugin-authoring/events/">Events</a></li>
              <li><a href="/plugin-authoring/localization/">Localization</a></li>
              <li><a href="/plugin-authoring/extensions/">Extensions</a></li>
              <li><a href="/plugin-authoring/testing/">Testing</a></li>
              <li><a href="/plugin-authoring/publishing/">Publishing</a></li>
            </ul>
          </li>
          <li class='dropdown'>
            <a href='/releases/'>
              Releases
              <b class='caret'></b>
            </a>
            <ul class='dropdown-menu'>
              <li><a href="/releases/4/">Lita 4</a></li>
              <li><a href="/releases/3/">Lita 3</a></li>
            </ul>
          </li>
          <li class='navbar-link'><a href="https://www.lita.io/">Lita.io <span class="glyphicon glyphicon-arrow-right"></span></a></li>
        </ul>
      </div>
    </nav>
    <div class='content'>
      <div class='container'>
        <div class='page-header'>
          <h1>Plugin Authoring</h1>
        </div>
        <div class='row'>
          <div class='col-md-3'>
            <nav>
              <ul class='nav nav-stacked'>
                <li>
                  <a href="/plugin-authoring/">Overview</a>
                  <ul>
                    <li><a href="/plugin-authoring/#plugin-types">Plugin types</a></li>
                    <li><a href="/plugin-authoring/#plugin-loading">Plugin loading</a></li>
                  </ul>
                </li>
                <li>
                  <a href="/plugin-authoring/adapters/">Adapters</a>
                  <ul>
                    <li><a href="/plugin-authoring/adapters/#generating">Generating an adapter</a></li>
                    <li><a href="/plugin-authoring/adapters/#configuration">Configuration</a></li>
                    <li><a href="/plugin-authoring/adapters/#required-methods">Required methods</a></li>
                    <li><a href="/plugin-authoring/adapters/#helper-methods">Helper methods</a></li>
                    <li><a href="/plugin-authoring/adapters/#chat-service">Chat-service-specific methods</a></li>
                    <li><a href="/plugin-authoring/adapters/#block-syntax">Block syntax</a></li>
                  </ul>
                </li>
                <li>
                  <a href="/plugin-authoring/handlers/">Handlers</a>
                  <ul>
                    <li><a href="/plugin-authoring/handlers/#chat-routes">Chat routes</a></li>
                    <li><a href="/plugin-authoring/handlers/#http-routes">HTTP routes</a></li>
                    <li><a href="/plugin-authoring/handlers/#event-routes">Event routes</a></li>
                    <li><a href="/plugin-authoring/handlers/#mixins">Mixins</a></li>
                    <li><a href="/plugin-authoring/handlers/#helper-methods">Helper methods</a></li>
                    <li><a href="/plugin-authoring/handlers/#timers">Timers</a></li>
                    <li><a href="/plugin-authoring/handlers/#configuration">Configuration</a></li>
                    <li><a href="/plugin-authoring/handlers/#chat-service">Chat-service-specific methods</a></li>
                    <li><a href="/plugin-authoring/handlers/#examples">Examples</a></li>
                  </ul>
                </li>
                <li>
                  <a href="/plugin-authoring/configuration/">Configuration</a>
                </li>
                <li>
                  <a href="/plugin-authoring/events/">Events</a>
                  <ul>
                    <li><a href="/plugin-authoring/events/#built-in-events">Built-in events</a></li>
                  </ul>
                </li>
                <li><a href="/plugin-authoring/localization/">Localization</a></li>
                <li>
                  <a href="/plugin-authoring/extensions/">Extensions</a>
                  <ul>
                    <li><a href="/plugin-authoring/extensions/#hooks">Hooks</a></li>
                    <li><a href="/plugin-authoring/extensions/#examples">Examples</a></li>
                    <li><a href="/plugin-authoring/extensions/#using-extensions">Using Extensions</a></li>
                  </ul>
                </li>
                <li>
                  <a href="/plugin-authoring/testing/">Testing</a>
                  <ul>
                    <li><a href="/plugin-authoring/testing/#setup">Setup</a></li>
                    <li><a href="/plugin-authoring/testing/#testing-adapters">Testing adapters</a></li>
                    <li><a href="/plugin-authoring/testing/#testing-handlers">Testing handlers</a></li>
                    <li><a href="/plugin-authoring/testing/#testing-routes">Testing routes</a></li>
                    <li><a href="/plugin-authoring/testing/#testing-behavior">Testing behavior</a></li>
                  </ul>
                </li>
                <li><a href="/plugin-authoring/publishing/">Publishing</a></li>
              </ul>
            </nav>
          </div>
          <div class='col-md-9'>
            <div class='page-header first-heading'>
              <h2>Extensions</h2>
            </div>
            <p>An extension is a plugin that adds new functionality to Lita's core in order to extend the capabilities of adapters and handlers. Unlike adapters and handlers, extensions are not used in a user's Lita project directly, but are dependencies of adapter and handler gems.</p>
            
            <p>To create a new extension plugin, run the following command in your shell: <kbd>lita extension <var>NAME_OF_YOUR_EXTENSION</var></kbd>. This generates the files necessary to build an extension plugin and publish it as a Ruby gem.</p>
            
            <div class="alert alert-info">
              <strong>Note:</strong>
              Extensions are an advanced topic and most of the time you won't need to write them yourself.
            </div>
            
            <h3 id="hooks">Hooks</h3>
            
            <p>Hooks are the primary mechanism for extensions to add new functionality to Lita's core. They are similar to the event system, allowing objects to register themselves with different hook names which get called when that hook is triggered. A callback object is registered using <code>Lita.register_hook</code>. The callback object is any object that responds to <code>:call</code> and accepts a single hash of payload data as an argument.</p>
            
            <p>The available hooks are as follows:</p>
            
            <table class="table table-bordered">
              <tr>
                <th>Name</th>
                <th>Description</th>
                <th>Payload</th>
              </tr>
              <tr>
                <td><code>:before_run</code></td>
                <td>Called when <code>Lita.run</code> is invoked, but before configuration is processed. Useful for extensions that need to perform operations just before the robot starts.</td>
                <td>
                  <ul>
                    <li><code>:config_path</code> (String) - The file path to the Lita config file that will be loaded, or <code>nil</code> if there is no config file.</li>
                  </ul>
                </td>
              </tr>
              <tr>
                <td><code>:config_finalized</code></td>
                <td>Called when <code>Lita.run</code> is invoked, after configuration is built, validated, and frozen.</td>
                <td>
                  <ul>
                    <li><code>:config_path</code> (String) - The file path to the Lita config file that will be loaded, or <code>nil</code> if there is no config file.</li>
                  </ul>
                </td>
              </tr>
              <tr>
                <td><code>:validate_route</code></td>
                <td>Called at the end of incoming message dispatch checks. If the the callback object returns <code>true</code>, the message will be dispatched to the route. If the callback object returns <code>false</code>, the message will fail to match the route, and the dispatcher moves on to trying the next route.</td>
                <td>
                  <ul>
                    <li><code>:handler</code> (Lita::Handler) - The handler class the route belongs to.</li>
                    <li><code>:route</code> (Lita::Handler::Route) - The route object for the route currently being validated.</li>
                    <li><code>:message</code> (Lita::Message) - The incoming message.</li>
                    <li><code>:robot</code> (Lita::Robot) - The currently running robot.</li>
                  </ul>
                </td>
              </tr>
              <tr>
                <td><code>:trigger_route</code></td>
                <td>Called when an incoming message has matched a route, just before the handler's callback method is invoked.</td>
                <td>
                  <ul>
                  <li><code>:response</code> (Lita::Response) - The response object that will be passed to the handler.</li>
                  <li><code>:route</code> (Lita::Handler::Route) - The route object for the route that matched.</li>
                  </ul>
                </td>
              </tr>
            </table>
            
            <h3 id="examples">Examples</h3>
            
            <p>Here is an extension that prevents routes with the custom <code>:password_protected</code> option from matching incoming messages unless they contain a secret password:</p>
            
            <pre><code class="language-ruby">module Lita&#x000A;  module Extensions&#x000A;    class PasswordProtection&#x000A;      def self.call(payload)&#x000A;        route = payload[:route]&#x000A;        message = payload[:message]&#x000A;&#x000A;        if route.extensions[:password_protected] &amp;&amp; !message.body.include?("secret")&#x000A;          return false&#x000A;        else&#x000A;          return true&#x000A;        end&#x000A;      end&#x000A;    end&#x000A;&#x000A;    Lita.register_hook(:validate_route, PasswordProtection)&#x000A;  end&#x000A;end&#x000A;</code></pre>
            
            <p>To take advantage of this extension, a handler would simply add the option in a route definition:</p>
            
            <pre><code class="language-ruby">route(/^dangerous/i, :dangerous_action, command: true, password_protected: true)&#x000A;</code></pre>
            
            <p>Here is an extension that adds the SHA1 hex digest of the incoming message's body to the response object passed to the handler:</p>
            
            <pre><code class="language-ruby">require "digest/sha1"&#x000A;&#x000A;module Lita&#x000A;  module Extensions&#x000A;    class MessageSHA&#x000A;      def self.call(payload)&#x000A;        response = payload[:response]&#x000A;&#x000A;        response.extensions[:sha] = Digest::SHA1.hexdigest(response.message.body)&#x000A;      end&#x000A;    end&#x000A;&#x000A;    Lita.register_hook(:trigger_route, MessageSHA)&#x000A;  end&#x000A;end&#x000A;</code></pre>
            
            <p>To take advantage of this extension, a handler just needs to access the value added to the response object:</p>
            
            <pre><code class="language-ruby">route(/^sha/i, :sha, command: true)&#x000A;&#x000A;def sha(response)&#x000A;  response.reply("The SHA1 of your message is: #{response.extensions[:sha]}.")&#x000A;end&#x000A;</code></pre>
            
            <p>For a more detailed example that makes use of both hooks and custom route options, check out <a href="https://github.com/jimmycuadra/lita-keyword-arguments">lita-keyword-arguments</a>.</p>
            
            <h3 id="using-extensions">Using extensions</h3>
            
            <p>When using an extension to add functionality to an adapter or handler you're writing, there are a few important "gotchas" to be aware of.</p>
            
            <p>Extensions do not "automatically activate" in the same way that adapters and handlers do when Lita is started. To load an extension, add it as a dependency in your plugin's gemspec file and manually <code>require</code> it inside your plugin's code, before the plugin is defined.</p>
            
            <p>When testing a handler with Lita's built-in RSpec extras, the <code>Lita::Registry</code> object that stores global state, including which extension hooks are registered, gets reset for each test run. This means that in order for extensions that register hooks to be active during each test run, you need to manually register them in a <code>before</code> block. If the documentation for the extension doesn't specify which hooks it registers, you may need to look at its source code to see for yourself.</p>
            
            <p>For example, the <a href="https://github.com/jimmycuadra/lita-keyword-arguments">lita-keyword-arguments</a> extension registers a callback to the <code>:trigger_route</code> hook. In order to activate it in tests, you would add the following code to your <code>spec/spec_helper.rb</code> file:</p>
            
            <pre><code class="language-ruby">RSpec.configure do |config|&#x000A;  config.before do&#x000A;    registry.register_hook(:trigger_route, Lita::Extensions::KeywordArguments)&#x000A;  end&#x000A;end&#x000A;</code></pre>
          </div>
        </div>
      </div>
    </div>
    <footer>
      <div class='container'>
        <ul class='nav navbar-nav'>
          <li><a href="https://github.com/jimmycuadra/lita">GitHub</a></li>
          <li><a href="https://twitter.com/litachatbot">Twitter</a></li>
          <li><a href="https://groups.google.com/group/litaio">Mailing List</a></li>
          <li><a href="http://webchat.freenode.net/?channels=lita.io">IRC</a></li>
          <li><a href="http://www.stickermule.com/marketplace/2466-lita">Stickers</a></li>
        </ul>
        <ul class='nav navbar nav navbar-right'>
          <li>
            <div class='navbar-text'>© 2015 Lita.io</div>
          </li>
        </ul>
      </div>
    </footer>
    <script src="/javascripts/application-7a3c79c9.js"></script>
  </body>
</html>
